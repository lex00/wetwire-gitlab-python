"""Kiro CLI configuration installer.

This module handles auto-installation of Kiro CLI configurations:
- Agent config (~/.kiro/agents/wetwire-runner.json)
- MCP config (.kiro/mcp.json in project directory)
"""

from __future__ import annotations

import json
import shutil
import subprocess
import sys
from pathlib import Path
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from typing import Any

# Embedded agent configuration
# Note: mcpServers will be populated dynamically with the correct path
AGENT_CONFIG: dict[str, Any] = {
    "name": "wetwire-runner",
    "description": "GitLab CI/CD pipeline generator using wetwire-gitlab Python syntax",
    "model": "claude-sonnet-4",
    "tools": ["*"],
    "mcpServers": {},  # Populated in install_agent_config
    "prompt": """You are a Runner agent that creates GitLab CI/CD pipelines using wetwire-gitlab.

Your job: Take the user's pipeline request and GENERATE THE CODE for it.

## MANDATORY LINT-FIX LOOP (NEVER SKIP)

Every time you write or edit code, you MUST follow this exact loop:

```
+-----------------------------------------------------+
|                  WRITE/EDIT CODE                    |
+-----------------------------------------------------+
                      |
                      v
+-----------------------------------------------------+
|              RUN wetwire_lint                       |
+-----------------------------------------------------+
                      |
              +-------+-------+
              |  Has errors?  |
              +-------+-------+
                      |
         +------------+------------+
         | YES                     | NO
         v                         v
+-----------------+    +-----------------------------+
|   FIX errors    |    |    RUN wetwire_build        |
+--------+--------+    +-----------------------------+
         |
         | (go back to lint)
         v
+-----------------------------------------------------+
|              RUN wetwire_lint AGAIN                 |
+-----------------------------------------------------+
         |
         +------> (repeat until no errors)
```

CRITICAL RULES:
1. NEVER run wetwire_build until wetwire_lint passes with zero errors
2. After EVERY fix, you MUST re-run wetwire_lint
3. The loop is: EDIT -> LINT -> FIX -> LINT -> FIX -> LINT -> ... -> BUILD
4. You are NOT DONE fixing until lint returns zero errors

## Package Structure (CRITICAL - READ CAREFULLY)

Step 1: ALWAYS use wetwire_init MCP tool first to create the package
Step 2: Create NEW .py files for jobs (jobs.py, stages.py, etc.)
Step 3: NEVER EVER touch __init__.py

```
my_pipeline/
+-- __init__.py      # AUTO-GENERATED - NEVER MODIFY THIS FILE
+-- jobs.py          # Create this file for Job definitions
+-- stages.py        # Create this file for stage constants
+-- pipeline.py      # Create this file for Pipeline configuration
```

FORBIDDEN ACTIONS:
- DO NOT edit __init__.py under any circumstances
- DO NOT add imports to __init__.py
- DO NOT add classes to __init__.py
- DO NOT modify __init__.py in any way

The __init__.py is generated by wetwire_init with the correct imports. Any modification will break the build.

## wetwire-gitlab Python Syntax Principles

1. JOBS - Define in jobs.py using Job dataclass:
   ```python
   from wetwire_gitlab.pipeline import Job, Artifacts, Cache, Rule
   from wetwire_gitlab.intrinsics import CI, When, Rules

   build = Job(
       name="build",
       stage="build",
       script=["make build"],
       artifacts=Artifacts(paths=["build/"]),
   )
   ```

2. PIPELINES - Define in pipeline.py:
   ```python
   from wetwire_gitlab.pipeline import Pipeline

   pipeline = Pipeline(stages=["build", "test", "deploy"])
   ```

3. TYPED VARIABLES - Use CI.*, GitLab.*, MR.* namespaces:
   ```python
   CI.COMMIT_SHA          # $CI_COMMIT_SHA
   CI.DEFAULT_BRANCH      # $CI_DEFAULT_BRANCH
   GitLab.USER_LOGIN      # $GITLAB_USER_LOGIN
   MR.SOURCE_BRANCH       # $CI_MERGE_REQUEST_SOURCE_BRANCH_NAME
   ```

4. PREDEFINED RULES - Use Rules constants:
   ```python
   deploy = Job(
       name="deploy",
       stage="deploy",
       script=["make deploy"],
       rules=[Rules.ON_DEFAULT_BRANCH],
   )
   ```

5. WHEN CONSTANTS - Use typed When values:
   ```python
   When.MANUAL      # 'manual'
   When.ALWAYS      # 'always'
   When.ON_SUCCESS  # 'on_success'
   ```

## Key Lint Rules (WGL001-WGL019)

- WGL001-005: Use typed dataclasses (Rule, Cache, Artifacts, Image)
- WGL003: Use predefined variables from intrinsics (CI, GitLab, MR)
- WGL009: Use predefined Rules constants (Rules.ON_DEFAULT_BRANCH)
- WGL010: Use typed When constants (When.MANUAL)
- WGL011-019: Job validation (missing stage, script, name, etc.)

## Design Workflow

EXAMPLE - Creating a build/test/deploy pipeline:

1. Use wetwire_init to create package:
   wetwire_init(path=".", module_name="my_pipeline")

2. Create jobs.py (NOT __init__.py) with content:
   ```python
   from wetwire_gitlab.pipeline import Job, Artifacts
   from wetwire_gitlab.intrinsics import Rules

   build = Job(
       name="build",
       stage="build",
       script=["npm install", "npm run build"],
       artifacts=Artifacts(paths=["dist/"]),
   )

   test = Job(
       name="test",
       stage="test",
       script=["npm test"],
       needs=["build"],
   )

   deploy = Job(
       name="deploy",
       stage="deploy",
       script=["npm run deploy"],
       rules=[Rules.ON_DEFAULT_BRANCH],
       needs=["test"],
   )
   ```

3. Run wetwire_lint:
   wetwire_lint(path="./my_pipeline")

4. IF LINT HAS ERRORS:
   a. Fix the errors in the code
   b. Run wetwire_lint AGAIN
   c. Repeat steps a-b until lint passes with ZERO errors

5. ONLY after lint passes with zero errors, run wetwire_build:
   wetwire_build(path="./my_pipeline")

IMPORTANT:
- Only call wetwire_init ONCE per package
- NEVER delete directories or start over - always fix errors in place
- NEVER modify __init__.py - only create/edit other .py files
- NEVER run wetwire_build while lint still has errors
- After EVERY fix, re-run wetwire_lint to verify

## Continuing Work on Existing Packages

When the user asks you to modify or extend an EXISTING package:

1. DO NOT run wetwire_init again - the package already exists
2. DO NOT touch __init__.py - it's already correctly configured
3. DO NOT try to "fix" the __init__.py - it is NOT broken
4. ONLY edit or create files like jobs.py, stages.py, pipeline.py, etc.

The __init__.py contains imports that auto-discover all .py files.
You do NOT need to import anything into __init__.py - it handles this automatically.

If you see an existing package with __init__.py, LEAVE IT ALONE and only work on the other files.

When modifying code, follow the MANDATORY LINT-FIX LOOP:
1. Edit the file
2. Run wetwire_lint
3. If errors: fix them, then go back to step 2
4. If no errors: run wetwire_build

REMEMBER: Fix -> Lint -> Fix -> Lint -> ... until zero errors, THEN build.""",
}


def get_agent_config_path() -> Path:
    """Get the path to the agent config file."""
    return Path.home() / ".kiro" / "agents" / "wetwire-runner.json"


def get_mcp_config_path(project_dir: Path | None = None) -> Path:
    """Get the path to the MCP config file."""
    if project_dir is None:
        project_dir = Path.cwd()
    return project_dir / ".kiro" / "mcp.json"


def check_kiro_installed() -> bool:
    """Check if Kiro CLI is installed and available."""
    return shutil.which("kiro-cli") is not None


def _get_mcp_server_path() -> str | None:
    """Find the absolute path to wetwire-gitlab-mcp command.

    Returns:
        Absolute path to the command, or None if not found.
    """
    # First check if it's in PATH
    mcp_path = shutil.which("wetwire-gitlab-mcp")
    if mcp_path:
        return mcp_path

    # Check common locations where uv/pip might install scripts
    try:
        # Try to find it via the current Python environment
        result = subprocess.run(
            [
                sys.executable,
                "-c",
                "import shutil; print(shutil.which('wetwire-gitlab-mcp') or '')",
            ],
            capture_output=True,
            text=True,
            timeout=10,
        )
        if result.returncode == 0 and result.stdout.strip():
            return result.stdout.strip()
    except (subprocess.TimeoutExpired, FileNotFoundError):
        pass

    return None


def install_agent_config(force: bool = False) -> bool:
    """Install the wetwire-runner agent config.

    Args:
        force: Overwrite existing config if True.

    Returns:
        True if config was installed, False if skipped.
    """
    config_path = get_agent_config_path()

    if config_path.exists() and not force:
        return False

    # Create a copy of the config to populate mcpServers
    config = AGENT_CONFIG.copy()

    # Find the MCP server path and add to agent config
    mcp_server_path = _get_mcp_server_path()
    if mcp_server_path:
        config["mcpServers"] = {
            "wetwire-gitlab-mcp": {
                "command": mcp_server_path,
                "args": [],
            }
        }
    else:
        # Fallback to uv run
        config["mcpServers"] = {
            "wetwire-gitlab-mcp": {
                "command": "uv",
                "args": ["run", "wetwire-gitlab-mcp"],
            }
        }

    config_path.parent.mkdir(parents=True, exist_ok=True)
    config_path.write_text(json.dumps(config, indent=2))
    return True


def install_mcp_config(project_dir: Path | None = None, force: bool = False) -> bool:
    """Install the MCP server config in project directory.

    Args:
        project_dir: Project directory. Defaults to current directory.
        force: Overwrite existing config if True.

    Returns:
        True if config was installed, False if skipped.
    """
    config_path = get_mcp_config_path(project_dir)

    # Load existing config or create new one
    if config_path.exists():
        if not force:
            # Check if wetwire-gitlab-mcp is already configured
            existing = json.loads(config_path.read_text())
            if "wetwire-gitlab-mcp" in existing.get("mcpServers", {}):
                return False
            # Merge with existing
            mcp_config = existing
        else:
            mcp_config = {"mcpServers": {}}
    else:
        mcp_config = {"mcpServers": {}}

    # Try to find absolute path to wetwire-gitlab-mcp
    mcp_server_path = _get_mcp_server_path()

    if mcp_server_path:
        # Use absolute path to the installed command
        mcp_config["mcpServers"]["wetwire-gitlab-mcp"] = {
            "command": mcp_server_path,
        }
    else:
        # Fall back to uv run (works if wetwire-gitlab is installed in project)
        mcp_config["mcpServers"]["wetwire-gitlab-mcp"] = {
            "command": "uv",
            "args": ["run", "wetwire-gitlab-mcp"],
        }

    config_path.parent.mkdir(parents=True, exist_ok=True)
    config_path.write_text(json.dumps(mcp_config, indent=2))
    return True


def install_kiro_configs(
    project_dir: Path | None = None, force: bool = False, verbose: bool = False
) -> dict[str, bool]:
    """Install all Kiro configurations.

    Args:
        project_dir: Project directory for MCP config. Defaults to cwd.
        force: Overwrite existing configs if True.
        verbose: Print status messages.

    Returns:
        Dict with 'agent' and 'mcp' keys indicating what was installed.
    """
    results = {
        "agent": install_agent_config(force=force),
        "mcp": install_mcp_config(project_dir=project_dir, force=force),
    }

    if verbose:
        if results["agent"]:
            print(f"Installed agent config: {get_agent_config_path()}", file=sys.stderr)
        if results["mcp"]:
            print(
                f"Installed MCP config: {get_mcp_config_path(project_dir)}",
                file=sys.stderr,
            )

    return results


def launch_kiro(prompt: str | None = None, project_dir: Path | None = None) -> int:
    """Launch Kiro CLI with the wetwire-runner agent.

    Args:
        prompt: Optional initial prompt for the conversation.
        project_dir: Project directory. Defaults to current directory.

    Returns:
        Exit code from kiro-cli.
    """
    if not check_kiro_installed():
        print(
            "Error: Kiro CLI not found. Install from https://kiro.dev/docs/cli/",
            file=sys.stderr,
        )
        return 1

    # Force reinstall configs every time to ensure latest agent prompt is used
    install_kiro_configs(project_dir=project_dir, force=True, verbose=True)

    # Build command
    cmd = ["kiro-cli", "chat", "--agent", "wetwire-runner", "--trust-all-tools"]
    # Always send an initial message to start the conversation
    # If user provided a prompt, use it; otherwise ask agent to introduce itself
    initial_message = (
        prompt if prompt else "Hello! I'm ready to design some GitLab CI/CD pipelines."
    )
    cmd.append(initial_message)

    # Launch Kiro
    try:
        result = subprocess.run(cmd, cwd=project_dir)
        return result.returncode
    except FileNotFoundError:
        print("Error: Failed to launch kiro-cli.", file=sys.stderr)
        return 1


def _run_with_script(
    cmd: list[str],
    cwd: Path,
    timeout: int,
) -> tuple[int, str, str]:
    """Run a command with a pseudo-terminal using the 'script' utility.

    kiro-cli requires a TTY even with --no-interactive, so we use
    the 'script' command to provide one. This is more robust than
    using Python's pty module directly.

    Args:
        cmd: Command and arguments to run.
        cwd: Working directory.
        timeout: Timeout in seconds.

    Returns:
        Tuple of (exit_code, stdout, stderr).
    """
    import platform
    import tempfile

    # Create a temp file for output
    with tempfile.NamedTemporaryFile(mode="w", suffix=".txt", delete=False) as f:
        output_file = f.name

    try:
        # Build script command - differs between macOS and Linux
        if platform.system() == "Darwin":
            # macOS: script -q output_file command args...
            script_cmd = ["script", "-q", output_file] + cmd
        else:
            # Linux: script -q -c "command args..." output_file
            script_cmd = ["script", "-q", "-c", " ".join(cmd), output_file]

        # Don't capture output - let script handle it via the output file
        # stdin from /dev/null to prevent blocking on input
        with open("/dev/null") as devnull:
            result = subprocess.run(
                script_cmd,
                cwd=cwd,
                stdin=devnull,
                stdout=subprocess.DEVNULL,
                stderr=subprocess.PIPE,
                text=True,
                timeout=timeout,
            )

        # Read output from file
        try:
            with open(output_file) as f:
                stdout = f.read()
        except FileNotFoundError:
            stdout = ""

        return result.returncode, stdout, result.stderr or ""

    except subprocess.TimeoutExpired:
        return -1, "", f"Timeout after {timeout} seconds"
    finally:
        # Clean up output file
        try:
            Path(output_file).unlink()
        except FileNotFoundError:
            pass


def run_kiro_scenario(
    prompt: str,
    project_dir: Path | None = None,
    timeout: int = 300,
    auto_exit: bool = True,
) -> dict[str, Any]:
    """Run a Kiro CLI scenario non-interactively for testing.

    This function runs kiro-cli with a prompt and captures output,
    suitable for automated testing and CI pipelines.

    Note: kiro-cli requires a TTY even with --no-interactive, so this
    function uses a pseudo-terminal (PTY) wrapper on Unix systems.

    Args:
        prompt: The pipeline prompt to send to Kiro.
        project_dir: Project directory. Defaults to temp directory.
        timeout: Maximum time in seconds to wait (default: 300).
        auto_exit: If True, append instruction to exit after completion.

    Returns:
        Dict with keys:
            - success: bool - Whether the scenario completed successfully
            - exit_code: int - Process exit code
            - stdout: str - Captured stdout
            - stderr: str - Captured stderr
            - package_path: str | None - Path to created package if any
            - template_valid: bool - Whether build produced valid template
    """
    import tempfile

    if not check_kiro_installed():
        return {
            "success": False,
            "exit_code": 1,
            "stdout": "",
            "stderr": "Kiro CLI not found",
            "package_path": None,
            "template_valid": False,
        }

    # Use temp directory if not specified
    if project_dir is None:
        temp_dir = tempfile.mkdtemp(prefix="kiro_test_")
        project_dir = Path(temp_dir)
    else:
        project_dir = Path(project_dir)
        project_dir.mkdir(parents=True, exist_ok=True)

    # Ensure configs are installed
    install_kiro_configs(project_dir=project_dir, verbose=False)

    # Build the full prompt with auto-exit instruction
    full_prompt = prompt
    if auto_exit:
        full_prompt = (
            f"{prompt}\n\n"
            "After successfully creating the package and running lint and build, "
            "output 'SCENARIO_COMPLETE' and exit."
        )

    # Build command for non-interactive execution
    # kiro-cli chat [OPTIONS] [INPUT] - input is positional
    cmd = [
        "kiro-cli",
        "chat",
        "--agent",
        "wetwire-runner",
        "--no-interactive",
        "--trust-all-tools",  # Auto-approve tool usage for non-interactive mode
        full_prompt,
    ]

    # Run kiro-cli with PTY wrapper (required even with --no-interactive)
    try:
        exit_code, stdout, stderr = _run_with_script(cmd, project_dir, timeout)
    except FileNotFoundError:
        return {
            "success": False,
            "exit_code": 1,
            "stdout": "",
            "stderr": "Failed to launch kiro-cli",
            "package_path": None,
            "template_valid": False,
        }

    # Handle timeout
    if exit_code == -1 and "Timeout" in stderr:
        return {
            "success": False,
            "exit_code": -1,
            "stdout": stdout,
            "stderr": stderr,
            "package_path": None,
            "template_valid": False,
        }

    # Find created package (look for directories with __init__.py)
    package_path = None
    for item in project_dir.iterdir():
        if item.is_dir() and (item / "__init__.py").exists():
            # Skip .kiro directory
            if item.name != ".kiro":
                package_path = str(item)
                break

    # Check if template is valid by running build
    template_valid = False
    if package_path:
        try:
            build_result = subprocess.run(
                ["wetwire-gitlab", "build", package_path],
                capture_output=True,
                text=True,
                timeout=30,
            )
            template_valid = build_result.returncode == 0
        except (subprocess.TimeoutExpired, FileNotFoundError):
            pass

    return {
        "success": exit_code == 0 and template_valid,
        "exit_code": exit_code,
        "stdout": stdout,
        "stderr": stderr,
        "package_path": package_path,
        "template_valid": template_valid,
    }
