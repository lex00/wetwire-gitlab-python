"""MCP server exposing wetwire-gitlab tools.

This module provides a Model Context Protocol (MCP) server that exposes
wetwire-gitlab functionality as tools for AI agents.

Tools:
    wetwire_init: Initialize a new wetwire-gitlab package
    wetwire_lint: Lint Python code for wetwire-gitlab issues
    wetwire_build: Generate .gitlab-ci.yml from a package
    wetwire_validate: Validate pipeline with glab CLI
    wetwire_import: Import existing YAML to Python

Usage:
    # Run as standalone server (stdio transport)
    wetwire-gitlab-mcp

    # Configure in MCP settings:
    {
        "mcpServers": {
            "wetwire-gitlab-mcp": {
                "command": "wetwire-gitlab-mcp"
            }
        }
    }
"""

from __future__ import annotations

import json
import sys
from dataclasses import asdict
from pathlib import Path
from typing import Any

from wetwire_core.mcp import MCP_AVAILABLE

if MCP_AVAILABLE:
    from mcp.server import Server
    from mcp.server.stdio import stdio_server
    from mcp.types import TextContent, Tool
else:
    Server = None  # type: ignore[misc, assignment]
    stdio_server = None  # type: ignore[misc, assignment]
    TextContent = None  # type: ignore[misc, assignment]
    Tool = None  # type: ignore[misc, assignment]


def _create_package(path: str, module_name: str) -> dict[str, Any]:
    """Create a new wetwire-gitlab package.

    Args:
        path: Directory where the package should be created.
        module_name: Name of the package (snake_case).

    Returns:
        Dict with 'success' and 'message' or 'error' keys.
    """
    output_dir = Path(path)
    if not output_dir.exists():
        return {"success": False, "error": f"Directory does not exist: {path}"}

    if not module_name.replace("_", "").isalnum():
        return {
            "success": False,
            "error": f"Invalid module name '{module_name}'. Use snake_case.",
        }

    package_dir = output_dir / module_name

    if package_dir.exists():
        return {
            "success": False,
            "error": f"Package already exists: {package_dir}",
        }

    # Create package directory
    package_dir.mkdir(parents=True, exist_ok=True)

    # Create __init__.py
    init_content = f'''"""{module_name} GitLab CI/CD configuration.

Generated by wetwire-gitlab init.
"""

from .jobs import *  # noqa: F403, F401
from .pipeline import *  # noqa: F403, F401
'''
    (package_dir / "__init__.py").write_text(init_content)

    # Create pipeline.py
    pipeline_content = '''"""Pipeline configuration."""

from wetwire_gitlab.pipeline import Pipeline

pipeline = Pipeline(
    stages=["build", "test", "deploy"],
)
'''
    (package_dir / "pipeline.py").write_text(pipeline_content)

    # Create jobs.py
    jobs_content = '''"""Job definitions."""

from wetwire_gitlab.pipeline import Job

build = Job(
    name="build",
    stage="build",
    script=["echo 'Building...'"],
)

test = Job(
    name="test",
    stage="test",
    script=["echo 'Testing...'"],
)
'''
    (package_dir / "jobs.py").write_text(jobs_content)

    return {
        "success": True,
        "message": f"Created package: {package_dir}",
        "path": str(package_dir),
    }


def _lint_path(path: str, fix: bool = False) -> dict[str, Any]:
    """Lint Python files for wetwire-gitlab issues.

    Args:
        path: Path to a Python file or directory.
        fix: If True, auto-fix detected issues (not implemented).

    Returns:
        Dict with 'issues' list.
    """
    from wetwire_gitlab.linter.linter import lint_file

    target = Path(path)
    if not target.exists():
        return {"success": False, "error": f"Path does not exist: {path}"}

    # Collect files to lint
    if target.is_file():
        files = [target]
    else:
        files = list(target.rglob("*.py"))
        # Exclude __pycache__ and hidden directories
        files = [
            f
            for f in files
            if "__pycache__" not in str(f)
            and not any(p.startswith(".") for p in f.parts)
        ]

    if not files:
        return {"success": True, "issues": [], "message": "No Python files found."}

    all_issues: list[dict[str, Any]] = []

    for filepath in files:
        result = lint_file(filepath)  # Pass Path object, not string
        for issue in result.issues:
            issue_dict = asdict(issue)
            all_issues.append(issue_dict)

    return {
        "success": True,
        "issues": all_issues,
        "issue_count": len(all_issues),
        "file_count": len(files),
    }


def _build_template(path: str, output_format: str = "yaml") -> dict[str, Any]:
    """Generate GitLab CI/CD configuration from a wetwire-gitlab package.

    Args:
        path: Path to the package directory.
        output_format: Output format, either 'yaml' or 'json'.

    Returns:
        Dict with 'template' containing the generated configuration.
    """
    from wetwire_gitlab.pipeline import Pipeline
    from wetwire_gitlab.runner.loader import extract_all_jobs, extract_all_pipelines
    from wetwire_gitlab.serialize.yaml_builder import build_pipeline_yaml

    package_path = Path(path).resolve()
    if not package_path.exists():
        return {"success": False, "error": f"Path does not exist: {path}"}
    if not package_path.is_dir():
        return {"success": False, "error": f"Path is not a directory: {path}"}
    if not (package_path / "__init__.py").exists():
        return {
            "success": False,
            "error": f"Path is not a Python package (missing __init__.py): {path}",
        }

    # Add parent directory to sys.path
    parent_dir = str(package_path.parent)
    if parent_dir not in sys.path:
        sys.path.insert(0, parent_dir)

    try:
        jobs = extract_all_jobs(package_path)
        pipelines = extract_all_pipelines(package_path)
    except Exception as e:
        return {"success": False, "error": f"Failed to discover resources: {e}"}

    if not jobs and not pipelines:
        return {
            "success": False,
            "error": "No jobs or pipelines found. Ensure your package defines Job or Pipeline instances.",
        }

    # Use first pipeline or create default
    pipeline = (
        pipelines[0] if pipelines else Pipeline(stages=["build", "test", "deploy"])
    )

    # Build output
    yaml_str = build_pipeline_yaml(pipeline, jobs)

    if output_format == "json":
        import yaml

        data = yaml.safe_load(yaml_str)
        output = json.dumps(data, indent=2)
    else:
        output = yaml_str

    return {
        "success": True,
        "template": output,
        "job_count": len(jobs),
        "pipeline_count": len(pipelines),
        "format": output_format,
    }


def _validate_pipeline(path: str) -> dict[str, Any]:
    """Validate a GitLab CI/CD configuration file.

    Args:
        path: Path to the .gitlab-ci.yml file.

    Returns:
        Dict with validation results.
    """
    from wetwire_gitlab.validation.glab import GlabNotFoundError, validate_file

    target = Path(path)
    if not target.exists():
        return {"success": False, "error": f"Path does not exist: {path}"}

    try:
        result = validate_file(target)
        return {
            "success": result.valid,
            "errors": result.errors or [],
            "merged_yaml": result.merged_yaml,
        }
    except GlabNotFoundError as e:
        return {"success": False, "error": str(e)}
    except Exception as e:
        return {"success": False, "error": f"Validation failed: {e}"}


def _import_yaml(path: str) -> dict[str, Any]:
    """Import a .gitlab-ci.yml file to Python code.

    Args:
        path: Path to the .gitlab-ci.yml file.

    Returns:
        Dict with 'code' containing the generated Python code.
    """
    from wetwire_gitlab.importer.codegen import generate_python_code
    from wetwire_gitlab.importer.parser import parse_gitlab_ci_file

    target = Path(path)
    if not target.exists():
        return {"success": False, "error": f"Path does not exist: {path}"}

    try:
        ir = parse_gitlab_ci_file(target)
        code = generate_python_code(ir)
        return {
            "success": True,
            "code": code,
            "job_count": len(ir.jobs),
        }
    except Exception as e:
        return {"success": False, "error": f"Import failed: {e}"}


def create_server() -> Server:
    """Create and configure the MCP server."""
    if not MCP_AVAILABLE or Server is None:
        raise ImportError(
            "MCP package required. Install with: pip install wetwire-gitlab[mcp]"
        )

    server = Server("wetwire-gitlab-mcp")

    @server.list_tools()
    async def list_tools() -> list[Tool]:
        """List available wetwire-gitlab tools."""
        return [
            Tool(
                name="wetwire_init",
                description="Initialize a new wetwire-gitlab CI/CD package",
                inputSchema={
                    "type": "object",
                    "properties": {
                        "path": {
                            "type": "string",
                            "description": "Directory where the package should be created",
                        },
                        "module_name": {
                            "type": "string",
                            "description": "Name of the package (snake_case, e.g., 'my_pipeline')",
                        },
                    },
                    "required": ["path", "module_name"],
                },
            ),
            Tool(
                name="wetwire_lint",
                description="Lint Python code for wetwire-gitlab issues (WGL001-WGL008)",
                inputSchema={
                    "type": "object",
                    "properties": {
                        "path": {
                            "type": "string",
                            "description": "Path to Python file or directory to lint",
                        },
                    },
                    "required": ["path"],
                },
            ),
            Tool(
                name="wetwire_build",
                description="Generate .gitlab-ci.yml from a wetwire-gitlab package",
                inputSchema={
                    "type": "object",
                    "properties": {
                        "path": {
                            "type": "string",
                            "description": "Path to the wetwire-gitlab package directory",
                        },
                        "format": {
                            "type": "string",
                            "enum": ["yaml", "json"],
                            "description": "Output format (default: yaml)",
                            "default": "yaml",
                        },
                    },
                    "required": ["path"],
                },
            ),
            Tool(
                name="wetwire_validate",
                description="Validate a .gitlab-ci.yml file using glab CLI",
                inputSchema={
                    "type": "object",
                    "properties": {
                        "path": {
                            "type": "string",
                            "description": "Path to the .gitlab-ci.yml file",
                        },
                    },
                    "required": ["path"],
                },
            ),
            Tool(
                name="wetwire_import",
                description="Import a .gitlab-ci.yml file to Python code",
                inputSchema={
                    "type": "object",
                    "properties": {
                        "path": {
                            "type": "string",
                            "description": "Path to the .gitlab-ci.yml file to import",
                        },
                    },
                    "required": ["path"],
                },
            ),
        ]

    @server.call_tool()
    async def call_tool(name: str, arguments: dict[str, Any]) -> list[TextContent]:
        """Handle tool calls."""
        if name == "wetwire_init":
            result = _create_package(
                path=arguments["path"],
                module_name=arguments["module_name"],
            )
        elif name == "wetwire_lint":
            result = _lint_path(path=arguments["path"])
        elif name == "wetwire_build":
            result = _build_template(
                path=arguments["path"],
                output_format=arguments.get("format", "yaml"),
            )
        elif name == "wetwire_validate":
            result = _validate_pipeline(path=arguments["path"])
        elif name == "wetwire_import":
            result = _import_yaml(path=arguments["path"])
        else:
            result = {"success": False, "error": f"Unknown tool: {name}"}

        return [TextContent(type="text", text=json.dumps(result, indent=2))]

    return server


async def run_server() -> None:
    """Run the MCP server with stdio transport."""
    if not MCP_AVAILABLE or stdio_server is None:
        raise ImportError(
            "MCP package required. Install with: pip install wetwire-gitlab[mcp]"
        )

    server = create_server()

    async with stdio_server() as (read_stream, write_stream):
        await server.run(
            read_stream, write_stream, server.create_initialization_options()
        )


def main() -> None:
    """Main entry point for the MCP server."""
    import asyncio

    try:
        asyncio.run(run_server())
    except ImportError as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)
    except KeyboardInterrupt:
        pass


if __name__ == "__main__":
    main()
